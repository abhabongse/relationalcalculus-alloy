% !TEX root = report.tex
\section{Model In Alloy Analyzer}

Alloy Analyzer is a tool for modeling objects with specifications regarding their related structure, and formally verifying whether some properties hold for such objects based on some other pre-asserted properties. Alloy has its own specification language as well as integrated development environment (\textsc{ide}), which includes a visualizer. The tool was developed by Daniel Jackson and his team at the Massachusetts Institute of Technology (\textsc{mit}). See Alloy manual in his book \cite{Jackson:2012:SAL:2141100} or on the Alloy website {\small\url{http://alloy.mit.edu/alloy/documentation.html}}.

To solve the \textsc{drc} query safety check problem, we rephrase the queries in terms of Alloy verification tasks. In this section, we explain the essential components of the model to we need to construct in Alloy specification language.


\subsection{Model overview}

The main question of this project is that, given a database schema and a \textsc{drc} query as input, we need to be able to translate the input into a verification task to be solved by Alloy Analyzer. Specifically, our Alloy model would consist of the following components.

\begin{itemize}[topsep=0.5pc,itemsep=0.25pc]
    \item  Since we need to show whether a \textsc{drc} query is domain-dependent, we need to be able to model multiple \textbf{domain sets} (see \sectionref{sub:goal}), each with different \textbf{scalar values} in the set.
    \item  The model needs to be able to model \textbf{database instances} (i.e., collection of table instances) based from the given database schema, using \textbf{scalar values} mentioned above.
    \item  The given \textsc{drc} query should be translated to a \textbf{query function} in Alloy language. The function should output a result given a \textbf{domain set} and a \textbf{database instance}.
    \item  As per the main goal in \sectionref{sub:goal}, we need an \textbf{Alloy predicate} which would solve for two distinct domains which yield two distinct query results based on a common database instance.
    \item \emph{Optional.} For visualization, we need a \textbf{placeholder for results} in the Alloy model, declared as a model signature.
\end{itemize}
We discuss the details for each of these components in depth in the subsequent subsections.


\subsection{Domain sets and values}

As previously mentioned, we need to be able to consider different domain sets in order to ultimately determine if a query is domain-dependent. In \autoref{src:domain},

\begin{itemize}[topsep=0.5pc,itemsep=0.25pc]
    \item  \textbf{\alloy{Superparticle}}:\; a set of all possible scalar values across all domains.
    \item  \textbf{\alloy{Universe}}:\; a collection of exactly two domains (or alternatively, \emph{universes}): \alloy{UniverseAlpha} and \alloy{UniverseBeta}. \; Each domain (i.e., \emph{universe}) has one attribute called \alloy{Element}, representing the subset of \alloy{Superparticle}s which belong to that domain. We can refer to the first domain set as \alloy{UniverseAlpha.Element}, for example.
    \item  \textbf{\alloy{Particle}}:\; is the domain set of \emph{allowable} scalar values in the actual model of database instances, which is restricted to the intersection of each of the two domain sets.
\end{itemize}

\begin{lstlisting}[language=alloy,float=t,caption={Alloy model signature for domain sets (\emph{universes}) and their elements (\emph{particles}). This stencil code will always be present in all Alloy models. The fact assert on \autoref{li:domain-cond} ensures that each \alloy{Superparticle} must be present in at least one domain, for the sake of conciseness of models generated by Alloy.},label={src:domain}]
sig Superparticle {} {
	Superparticle = Universe.Element <|\label{li:domain-cond}|>
}

abstract sig Universe { Element: some Superparticle }
one sig UniverseAlpha, UniverseBeta extends Universe {}

some sig Particle in Superparticle {} {
	Particle = UniverseAlpha.Element & UniverseBeta.Element
}
\end{lstlisting}


\subsection{Database instances}

Because database instances will heavily depend on the schema, instead of creating a static Alloy model, we need a method to translate the given database schema into additional Alloy model signatures. We provide a framework procedure of how it could be done.

\smallskip
\begin{procedure}
    \label{proc:tables}
    Let $R_1, R_2, \ldots, R_k$ be database tables, each with $n_1, n_2, \ldots, n_k$ columns, respectively. We create the following Alloy signature.

    % Code placeholder variables
    \newrobustcmd\fieldsigfortable[1]{%
        \textnormal{\small\color{CodeVariable}
            <\hrsp{\itshape field signature #1}\hrsp>}}

\begin{lstlisting}[language=alloy,numbers=none]
one sig Table {
    R_1: <|\fieldsigfortable{$R_1$}|>,
    R_2: <|\fieldsigfortable{$R_2$}|>,
               <|$\vdots$|>
    R_<|$k$|>: <|\fieldsigfortable{$R_k$}|>
}
\end{lstlisting}

    \newpage\phantomsection
    \label{psec:foot-dummy}
    \marginnote{\llap{\normalsize* }The reason why we need a dummy signature \alloy{Table} is that it is impossible in Alloy to create a relation with each column consisting of object with only pre-defined signatures. Hence, this is a workaround.}
    \noindent
    where
    \[
        \text{\fieldsigfortable{$R_i$}} = \begin{cases}
            \;\text{\small\alloy{set Particle}}
                & \text{if $n_i = 1$} \\
            \;\underbrace{\text{\small\alloy{Particle -> Particle ->} $\ldots$ \alloy{-> Particle}}}_\text{repeated $n_i$ times}
                & \text{if $n_i > 1$}
        \end{cases}
    \]
    In other words, each field \alloy{R_}$i$ is an Alloy relation with $n_i$ columns (ignoring the first dummy column of the \alloy{Table} signature\hrsp{\hyperref[psec:foot-dummy]{\color{OrangeRed4}*}}), and \alloy{Table.R_}$i$ is the syntax which represents table $R_i$ itself.

    Note that the unary signature (i.e., table with single column) requires the keyword \alloy{set} in order to override the default behavior which is that \alloy{Table.R_}$i$ would have contained a single row of data instead of any number of rows.
\end{procedure}

\marginhead{Example of translation of database schema}
To illustrate how the above procedure works, we consider the following example.

\smallskip
\begin{example}
    Suppose that a database schema consists of three tables named \rel{A}, \rel{B}, and \rel{C}. Table \rel{A} has a single column of integers; Table \rel{B} contains two columns of integers followed by a column of string values; and Table \rel{C} contains two columns of string values.

    Using \autoref{proc:tables}, all of the tables above are translated into Alloy signature as follows.
\begin{lstlisting}[language=alloy,numbers=none]
one sig Table {
    A: set Particle
    B: Particle -> Particle -> Particle
    C: Particle -> Particle
}
\end{lstlisting}
\end{example}

\begin{note}
    You may have probably noticed from the example above that we make \emph{no distinction} between different types of data, whether it be an integer or a string (or any other types). Since data types do not make any differences in this project, they can be safely disregarded.
\end{note}


\subsection{Query function}

Suppose that a (simplified) \textsc{drc} query has the form
\begin{equation}
    Q = \{x_1,x_2,\ldots,x_m \mid P(x_1,x_2,\ldots,x_m)\} \label{eq:query}
\end{equation}
where each $x_i$ represents a variable for scalar value and $P$ is a boolean expression, which could be

\begin{itemize}[topsep=0.5pc,itemsep=0.25pc]
    \item  a boolean predicate in terms of table name (see \hyperref[psec:table-name-pred]{page~\pageref*{psec:table-name-pred} under \emph{table names as predicates}});
    \item  an equality predicate ($=$) between two values;
    \item  a conjunction ($\wedge$), a disjunction ($\vee$), a negation ($\neg$\hrsp), a conditional ($\Rightarrow$), or a bi-conditional ($\Leftrightarrow$) of other boolean expressions; or
    \item  a first-order, universal ($\forall$) or existential ($\exists$) quantification of other boolean expressions where a new variable also represents a scalar value.
\end{itemize}

In addition, each variable in the boolean expression $P$ must be \emph{binded}. That is, either the variable must be one of $x_1,x_2,\ldots,x_m$; or it must be introduced via first-order quantification in which the variable is used.

\smallskip
The procedure to transform a query in \textsc{drc} into an Alloy function is described as follows.

\smallskip
\begin{procedure}
    \label{proc:query-function}
    Given a specific \alloy{Universe} (i.e., domain set) called $u$ as an input, we rewrite the query $Q$ as defined in \eqref{eq:query} as a new Alloy function (using a comprehension syntax) as shown.

    % Code placeholder variables
    \newrobustcmd\setcomppred{%
        \textnormal{\small\color{CodeVariable}
            <\hrsp{\itshape predicate expression}\hrsp>}}
    \newrobustcmd\resultsig{%
        \textnormal{\small\color{CodeVariable}
            <\hrsp{\itshape output signature}\hrsp>}}
    % Make an escape within string
    \newrobustcmd\escinstr[1]{{\color{Purple4!80!black}\$\{#1\}}}

\begin{lstlisting}[language=alloy,numbers=none]
fun query[u: Universe]: <|\resultsig|> {
    { x_1,x_2,<|$\ldots$|>,x_<|$m$|>: u.Element | <|\setcomppred|> }
}
\end{lstlisting}
    The \setcomppred{} above corresponds to the almost one-to-one translation of the boolean expression $P$ (from the query $Q$ as shown in \eqref{eq:query}) into an Alloy predicate syntax string. The recursive translational algorithm is outlined below.

\SuppressNumber
\begin{lstlisting}[language=pseudocode,escapeinside={<|}{|>},emph={TranslateBooleanExp},emphstyle={\bfseries\color{Identifier}}]
TranslateBooleanExp($P$):  <|\ReactivateNumber|>
if $P$ is a table-name predicate $T(x_1, x_2, \ldots, x_m)$:
    return "<|\escinstr{$x_1$}|> $\color{String}\rightarrow$ <|\escinstr{$x_2$}|> $\color{String}\rightarrow$ $\ldots$ $\color{String}\rightarrow$ <|\escinstr{$x_m$}|> in Table.<|\escinstr{$T$}|>"
else if $P$ is the equality predicate $x_1 = x_2$:
    return "(<|\escinstr{$x_1$}|> = <|\escinstr{$x_2$}|>)"
else if $P$ has the form $\neg Q$:
    return "(not <|\escinstr{TranslateBooleanExp($Q$)}|>)"
else if $P$ has the form $Q \vee R$:
    return "(<|\escinstr{TranslateBooleanExp($Q$)}|> or <|\escinstr{TranslateBooleanExp($R$)}|>)"
else if $P$ has the form $Q \wedge R$:
    return "(<|\escinstr{TranslateBooleanExp($Q$)}|> and <|\escinstr{TranslateBooleanExp($R$)}|>)"
else if $P$ has the form $Q \Rightarrow R$:
    return "(<|\escinstr{TranslateBooleanExp($Q$)}|> implies <|\escinstr{TranslateBooleanExp($R$)}|>)"
else if $P$ has the form $Q \Leftrightarrow R$:
    return "(<|\escinstr{TranslateBooleanExp($Q$)}|> iff <|\escinstr{TranslateBooleanExp($R$)}|>)"
else if $P$ has the form $\exists\,y[Q]$:
    return "(some <|\escinstr{$y$}|>: u.Element | <|\escinstr{TranslateBooleanExp($Q$)}|>)"
else if $P$ has the form $\forall y[Q]$:
    return "(all <|\escinstr{$y$}|>: u.Element | <|\escinstr{TranslateBooleanExp($Q$)}|>)"
\end{lstlisting}

    \newpage\noindent
    In other words, the translation propagates down through each boolean subexpressions, except for the case of table-name predicates in which we use ``arrow products'' (\alloy{->}) and ``subset comparison operator'' (\alloy{in}) to check if a tuple belongs to the given table. Hence, this procedure is straightforward.

    For the \resultsig{}, we use the syntax similar to that in \autoref{proc:tables}.
    \[
        \text{\resultsig} = \begin{cases}
            \;\text{\small\alloy{set Superparticle}}
                & \text{if $m = 1$} \\
            \;\underbrace{\text{\small\alloy{Superparticle -> Superparticle ->} $\ldots$ \alloy{-> Superparticle}}}_\text{repeated $m$ times}
                & \text{if $m > 1$}
        \end{cases}
    \]


\end{procedure}

\newpage
\marginhead{Example of translation of query functions}
The following example demonstrates how we can translate one instance of \textsc{drc} query into an Alloy function.

\smallskip
\begin{example}
    Suppose that there exists a table $\rel{T}(\field{a, b})$ and we have a \textsc{drc} query $Q$ such that
    \[
        Q = \{ x, y \mid (x = y) \vee \rel{T}(x, y) \vee \exists z [\rel{T}(x, z) \wedge \rel{T}(z, y)] \}
    \]
    Using \autoref{proc:query-function}, query $Q$ can be rewritten as an Alloy function as follows.

\begin{lstlisting}[language=alloy]
fun query[u: Universe]: Superparticle -> Superparticle {
    { x, y: u.Element |
        ((x = y) or (x -> y in Table.T) or
         (some z: u.Element | (x -> z in Table.T) and
                              (z -> y in Table.T))) }
}
\end{lstlisting}
\end{example}

We have discussed earlier at the end of \sectionref{psec:explicit-domain} about how the domain of a \textsc{drc} query is \emph{not} explicit. In an attempt to make the domain more explicit, we provide the following definition and notation.

\smallskip
\begin{definition}
    \label{def:query-interp}
    Let $Q$ be a \textsc{drc} query as mentioned in \eqref{eq:query}. If the domain set is $D$, then $Q[D]$ denotes
    \[
        Q[D] = \{(x_1,x_2,\ldots,x_m) \in D^m \mid P(x_1,x_2,\ldots,x_m)\}
    \]
    That is, each row of $Q[D]$ will be a tuple of $m$ scalar values from the domain $D$.

    We also sometimes interpret $Q[D]$ as the \textbf{result} of the query $Q$ where $D$ is the domain. This interpretation directly corresponds to how the \alloy{query} function works as defined by \autoref{proc:query-function}
\end{definition}


\subsection{Query safety verification}

Let us revisit the definition of the ``\textit{safety} of \textsc{drc} query'' as described in \sectionref{sub:goal}. We rephrase the definition slightly so that it exactly fits the Alloy verification framework.

\begin{definition}
    Suppose there exists a database schema $S$ and a \textsc{drc} query syntax $Q$ (as defined in \eqref{eq:query}). The query $Q$ is \textbf{safe} \emph{if and only if}
    \begin{itemize}[topsep=0.5pc,itemsep=0.25pc]
        \item  \textit{for all} two domain sets $D_1$ and $D_2$, and
        \item  \textit{for every} database instances $I$ based on the schema $S$, which are also valid under both domains $D_1$ and $D_2$ (i.e., all scalar values in $I$ must belong to both sets $D_1$ and $D_2$)
    \end{itemize}
    we have $Q[D_1] = Q[D_2]$ \;(i.e., the result of query $Q$ under $D_1$ and $D_2$ are the same).
\end{definition}

\smallskip
The definiton of query safety can be translated into an Alloy assertion statement as shown on the first three lines in \autoref{src:safety}. The \hyperref[li:check-assert]{last line} invokes the Alloy Analyzer to verify such assertion statement. The hightlighted number \alloy{4} indicates the upper limit of the number of objects of each model to be constructed by Alloy Analyzer. This number could be changed to a larger or smaller amount. The larger the amount, the more likely that Alloy Analyzer finds the answer, but in exchange for more computation resources.

\begin{lstlisting}[language=alloy,float={t},caption={Alloy assertion statement indicating that the \alloy{query} is true.},label={src:safety}]
assert queryIsSafe {
    all u, u': Universe | query[u] = query[u']
}
check queryIsSafe for <|\hll{check-assert-num}|>4<|\hlr{check-assert-num}\label{li:check-assert}|>
\end{lstlisting}

\begin{note}
    \marginhead{Caveat of Alloy Analyzer}
    It is vital to point out that Alloy Analyzer will only attempt to find a counterexample of a given assertion statement. If Alloy Analyzer fails to find such counterexample, it does \emph{not} imply that the assertion is true. That is, the Alloy Analyzer is \textbf{not complete}.
\end{note}

\smallskip
So far we have discussed all essential ingredients of our Alloy model to analyze the safety of a \textsc{drc} query input. However, when the query safety assertion statement has a counterexample, and we would like to see the explicit visualization of the query result of the counterexample, we will need to provide the Alloy model signature for the result objects too.


\subsection{Results placeholder}

As we have previously discussed in \autoref{def:query-interp} that the query result is the interpretation of a query for a given domain set. Considering from the mathematical point of view, it is easy to see that the query result actually has the same anatomy as database tables. That is, a \textbf{query result} is a mathematical relation with a positive number of columns of scalar values. Therefore, we can use the syntax similarly to the declaration signature of table objects.

However, there is one major difference: for each query, we need two query results, one for domain \alloy{UniverseAlpha} and another for \alloy{UniverseBeta}. In Alloy, we use the following procedure to translate the \textsc{drc} query to the Alloy object signature as shown below.

\smallskip
\begin{procedure}
    Let $Q$ be a given \textsc{drc} query as defined in \eqref{eq:query}. That is, each row of the result has $m$ columns. We create Alloy objects with the following signatures.

    \newrobustcmd\fieldsigforresult{%
        \textnormal{\small\color{CodeVariable}
            <\hrsp{\itshape field signature}\hrsp>}}

\begin{lstlisting}[language=alloy,numbers=none]
abstract sig Result {
    Output: <|\fieldsigforresult|>
}
one sig ResultAlpha, ResultBeta extends Result {} {
    ResultAlpha.@Output = query[UniverseAlpha]
    ResultBeta.@Output = query[UniverseBeta]
}
\end{lstlisting}
    where
    \[
        \text{\fieldsigforresult} = \begin{cases}
            \;\text{\small\alloy{set Superparticle}}
                & \text{if $m = 1$} \\
            \;\underbrace{\text{\small\alloy{Superparticle -> Superparticle ->} $\ldots$ \alloy{-> Superparticle}}}_\text{repeated $m$ times}
                & \text{if $m > 1$}
        \end{cases}
    \]

    Notice that there are two separate results of the query (called the \alloy{Output}) from applying \alloy{query} function to each domain.
\end{procedure}
